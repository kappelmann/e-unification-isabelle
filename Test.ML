signature TEST = 
sig
  type unificationf
  type unif_test = Proof.context -> unificationf -> Envir.env -> int -> bool
  type unif_test_gen = Proof.context -> unificationf -> Envir.env -> term Gen_Base.gen -> int -> bool
  val unification_gen : Proof.context -> unificationf -> Envir.env -> term Gen_Base.gen -> (Envir.env * thm)
  val sym_h_unif : unif_test_gen
  val certificate_h_unif : unif_test_gen
  val certificate_thm_h_unif : unif_test_gen
  val non_unifiable_const_free : unif_test
  val unifiable_const_free : unif_test
  val unifiable_var_term : unif_test_gen
  val unifiable_vars_replaced : unif_test_gen
  val fun_free_const_free_gen : term Gen_Term.gen
  
end

structure Test : TEST =
struct
type unificationf = Proof.context -> term * term -> Envir.env -> (Envir.env * thm)
type unif_test = Proof.context -> unificationf -> Envir.env -> int -> bool
type unif_test_gen = Proof.context -> unificationf -> Envir.env -> term Gen_Base.gen -> int -> bool

exception TestFailed of (term * term)

(* generates a tuple of terms using generator tgen *)
fun gen_termtup tgen rand =
  let val (t1,rand1) = tgen rand
      val (t2,rand2) = tgen rand1
  in ((t1,t2),rand2) end

(* generates a list of term tuples of length i using generator tgen *)
fun gen_termtups i tgen =
  fold (fn _ => fn (ts,rand) => let val (ttup,new_rand)=gen_termtup tgen rand in (ttup::ts,new_rand) end) (replicate i ()) ([],Random.new())

fun gen_terms i tgen =
  fold (fn _ => fn (ts,rand) => let val (t,new_rand)=tgen rand in (t::ts,new_rand) end) (replicate i ()) ([],Random.new())

val fun_free_const_free_gen = Gen_Term.term_fol (Gen_Term.def_sym_gen (1.0,0.0,1.0) 2) 5 1

fun unification_gen ctxt unif envir tgen =
  let
    val (t1,rand) = tgen (Random.new ())
    val (t2,_) = tgen rand
    val _ = writeln "Terms: "
    val _ = pwriteln (pretty_term ctxt t1)
    val _ = pwriteln (pretty_term ctxt t2)
    val (env,thm) = unif ctxt (t1,t2) envir
    val _ = pretty_envs ctxt env
    val _ = pretty_thm ctxt thm
  in (env,thm) end

(* checks if two terms unify using unif *)
fun terms_unify ctxt unif envir (t1,t2) =
  let val (env,thm) = unif ctxt (t1,t2) envir
  in true handle _ => false end

val terms_from_thm =
  (fn (Const ("Pure.eq",_) $ t1 $ t2) => (t1,t2)) o Thm.concl_of

fun replace_vars tgen rand = fn
  Var _ => tgen rand
 |f$x =>
   let val (f',rand1) = replace_vars tgen rand f
       val (x',rand2) = replace_vars tgen rand1 x
   in (f' $ x',rand2) end
 |t => (t,rand)

(* checks i tuples of terms generated by tgen for symmetry *)
fun sym_h_unif ctxt unif envir tgen i =
  forall
    (fn (t1,t2) =>
      if terms_unify ctxt unif envir (t1,t2) = terms_unify ctxt unif envir (t2,t1) then true
      else raise TestFailed (t1,t2))  
    (gen_termtups i tgen |> fst)

(* checks i tuples of terms generated by tgen for correctness of sigma *)
fun certificate_h_unif ctxt unif envir tgen i =
  forall
    (fn (t1,t2) =>
      let val (sigma,_) = unif ctxt (t1,t2) envir in
        if Envir.norm_term sigma t1 = Envir.norm_term sigma t2 then true
        else raise TestFailed (t1,t2) end)
    (gen_termtups i tgen |> fst)

(* checks i tuples of terms generated by tgen for correctness of thm *)
fun certificate_thm_h_unif ctxt unif envir tgen i =
  forall
    (fn (t1,t2) =>
      let val (sigma,thm) = unif ctxt (t1,t2) envir
          val (lhs,rhs) = terms_from_thm thm in
        if (Envir.norm_term sigma t1,Envir.norm_term sigma t2) = (lhs,rhs)
           orelse (Envir.norm_term sigma t1,Envir.norm_term sigma t2) = (rhs,lhs) then true
        else raise TestFailed (t1,t2) end)
    (gen_termtups i tgen |> fst)

(* checks i tuples of function-free consts or frees for non-unifiability *)
fun non_unifiable_const_free ctxt unif envir i =
  forall
    (fn (t1,t2) =>
      if t1=t2 orelse not (terms_unify ctxt unif envir (t1,t2)) then true
      else raise TestFailed (t1,t2))
    (gen_termtups i fun_free_const_free_gen |> fst)

(* checks i tuples of function-free consts or frees for unifiability *)
fun unifiable_const_free ctxt unif envir i =
  forall
    (fn (t1,t2) =>
      if t1=t2 andalso (terms_unify ctxt unif envir (t1,t2)) then true
      else raise TestFailed (t1,t2))
    (gen_termtups i fun_free_const_free_gen |> fst)

fun unifiable_var_term ctxt unif envir tgen i =
  forall
    (fn t =>
      if terms_unify ctxt unif envir (Var(("A",300),TVar(("'a",300),[])),t) then true
      else raise TestFailed (t,t))
    (gen_terms i tgen |> fst)

fun unifiable_vars_replaced ctxt unif envir tgen i =
  forall
    (fn t =>
      if terms_unify ctxt unif envir (t,replace_vars fun_free_const_free_gen (Random.new ()) t |> fst)
      then true
      else raise TestFailed (t,t))
    (gen_terms i tgen |> fst)

end