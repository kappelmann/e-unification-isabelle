signature TEST = 
sig
  val test_h_unif : Proof.context -> Envir.env -> term Gen_Base.gen -> (Envir.env * thm)
  val sym_h_unif : Proof.context -> Envir.env -> term Gen_Base.gen -> int -> bool
  val certificate_h_unif : Proof.context -> Envir.env -> term Gen_Base.gen -> int -> bool
end

structure Test : TEST =
struct

exception TestFailed of (term * term)

(* generates a tuple of terms using generator tgen *)
fun gen_termtup tgen =
  let val (t1,rand1) = tgen (Random.new())
      val (t2,_) = tgen rand1
  in (t1,t2) end

(* generates a list of term tuples of length i using generator tgen *)
fun gen_termtups i tgen =
  fold (fn _ => fn ts => (gen_termtup tgen)::ts) (replicate i ()) []

fun test_h_unif ctxt envir tgen =
  let
    val (t1,rand) = tgen (Random.new ())
    val (t2,_) = tgen rand
    val _ = writeln "Terms: "
    val _ = pwriteln (pretty_term ctxt t1)
    val _ = pwriteln (pretty_term ctxt t2)
    val (env,thm) = Fou.hint_unify ctxt (Fou.gen_hint_list ctxt) (t1,t2) envir
    val _ = pretty_envs ctxt env
    val _ = pretty_thm ctxt thm
  in (env,thm) end

fun terms_unify ctxt envir (t1,t2) =
  let val (env1,thm1) = Fou.hint_unify ctxt (Fou.gen_hint_list ctxt) (t1,t2) envir
  in true handle _ => false end

(* checks i tuples of term generated by tgen for symmetry *)
fun sym_h_unif ctxt envir tgen i =
  forall
    (fn (t1,t2) =>
      if terms_unify ctxt envir (t1,t2) = terms_unify ctxt envir (t2,t1) then true
      else raise TestFailed (t1,t2))  
    (gen_termtups i tgen)

(* checks i tuples of term generated by tgen for correctness of sigma *)
fun certificate_h_unif ctxt envir tgen i =
  forall
    (fn (t1,t2) =>
      let val (sigma,_) = Fou.hint_unify ctxt (Fou.gen_hint_list ctxt) (t1,t2) envir in
        if Envir.norm_term sigma t1 = Envir.norm_term sigma t2 then true
        else raise TestFailed (t1,t2) end)
    (gen_termtups i tgen)

val terms_from_thm =
  (fn Const ("HOL.Trueprop",_) $ (Const ("HOL.eq",_) $ t1 $ t2) => (t1,t2)) o Thm.concl_of

(* checks i tuples of term generated by tgen for correctness of thm *)
fun certificate_thm_h_unif ctxt envir tgen i =
  forall
    (fn (t1,t2) =>
      let val (sigma,thm) = Fou.hint_unify ctxt (Fou.gen_hint_list ctxt) (t1,t2) envir
          val (lhs,rhs) = terms_from_thm thm in
        if (Envir.norm_term sigma t1,Envir.norm_term sigma t2) = (lhs,rhs)
           orelse (Envir.norm_term sigma t1,Envir.norm_term sigma t2) = (rhs,lhs) then true
        else raise TestFailed (t1,t2) end)
    (gen_termtups i tgen)



end